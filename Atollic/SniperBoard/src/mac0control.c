/*
 * mac0control.c
 *
 *  Created on: Apr 22, 2017
 *      Author: Aravindan
 */
#include <stddef.h>
#include "stm32f10x.h"
#include <stdio.h>
#include "sys_usart.h"
#include "sys_timer.h"
#include "sys_spi.h"
#include "uip/enc424J600.h"
#include "uip/uip-conf.h"
#include "uip/uip.h"
#include "uip/uip_arp.h"
#include "uip/uip_timer.h"
#include "uip/dhcpc.h"
#include "uip/Enc424J600NetworkP0.h"
#include "mac0control.h"

#define DHCP

#define uip_ip_addr(addr, ip) do { \
                     ((u16_t *)(addr))[0] = HTONS(((ip[0]) << 8) | (ip[1])); \
                     ((u16_t *)(addr))[1] = HTONS(((ip[2]) << 8) | (ip[3])); \
                  } while(0)
#define uip_seteth_addr(eaddr) do {uip_ethaddr.addr[0] = eaddr[0]; \
                              uip_ethaddr.addr[1] = eaddr[1];\
                              uip_ethaddr.addr[2] = eaddr[2];\
                              uip_ethaddr.addr[3] = eaddr[3];\
                              uip_ethaddr.addr[4] = eaddr[4];\
                              uip_ethaddr.addr[5] = eaddr[5];} while(0)
#define BUF ((struct uip_eth_hdr *)&uip_buf[0])





uint8_t dhcp_acquired =0;
//uint8_t tstpkt[] = {0x1C,0x6F,0x65,0x8A,0x1E,0x24,0x48,0x48,0x48,0x48,0x48,0x48,0x08,0x06,0x00,0x01,0x08,0x00,0x06,0x04,0x00,0x02,0x48,0x48,0x48,0x48,0x48,0x48,0xC0,0xA8,0x01,0x4B,0x1C,0x6F,0x65,0x8A,0x1E,0x24,0xC0,0xA8,0x01,0x19};
uint8_t tstreg[] = {0x50,0x4F,0x53,0x54,0x20,0x2F,0x46,0x50,0x57,0x65,0x62,0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x2F,0x66,0x70,0x73,0x65,0x72,0x76,0x69,0x63,0x65,0x73,0x2F,0x41,0x6C,0x61,0x72,0x6D,0x44,0x65,0x76,0x69,0x63,0x65,0x73,0x2E,0x6A,0x73,0x6F,0x6E,0x2F,0x73,0x61,0x76,0x65,0x41,0x6C,0x61,0x72,0x6D,0x44,0x65,0x76,0x69,0x63,0x65,0x3F,0x62,0x75,0x69,0x6C,0x64,0x69,0x6E,0x67,0x49,0x64,0x3D,0x37,0x26,0x64,0x65,0x76,0x69,0x63,0x65,0x49,0x64,0x3D,0x52,0x4F,0x56,0x45,0x5F,0x30,0x30,0x32,0x26,0x69,0x6E,0x73,0x74,0x61,0x6C,0x6C,0x65,0x64,0x46,0x6C,0x6F,0x6F,0x72,0x4E,0x6F,0x3D,0x36,0x26,0x75,0x70,0x64,0x61,0x74,0x65,0x64,0x42,0x79,0x3D,0x41,0x6C,0x61,0x72,0x6D,0x44,0x65,0x76,0x69,0x63,0x65,0x26,0x69,0x73,0x55,0x70,0x64,0x61,0x74,0x65,0x3D,0x66,0x61,0x6C,0x73,0x65,0x20,0x48,0x54,0x54,0x50,0x2F,0x31,0x2E,0x31,0x0D,0x0A,0x41,0x63,0x63,0x65,0x70,0x74,0x3A,0x20,0x61,0x70,0x70,0x6C,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x2F,0x6A,0x73,0x6F,0x6E,0x0D,0x0A,0x55,0x73,0x65,0x72,0x2D,0x41,0x67,0x65,0x6E,0x74,0x3A,0x20,0x4A,0x61,0x76,0x61,0x2F,0x31,0x2E,0x38,0x2E,0x30,0x5F,0x36,0x35,0x0D,0x0A,0x48,0x6F,0x73,0x74,0x3A,0x20,0x31,0x34,0x34,0x2E,0x32,0x31,0x37,0x2E,0x39,0x31,0x2E,0x33,0x32,0x3A,0x38,0x30,0x38,0x30,0x0D,0x0A,0x43,0x6F,0x6E,0x6E,0x65,0x63,0x74,0x69,0x6F,0x6E,0x3A,0x20,0x6B,0x65,0x65,0x70,0x2D,0x61,0x6C,0x69,0x76,0x65,0x0D,0x0A,0x0D,0x0A};
//Floor 4
uint8_t tstpkt0[]  = {0x50,0x4F,0x53,0x54,0x20,0x2F,0x46,0x50,0x57,0x65,0x62,0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x2F,0x66,0x70,0x73,0x65,0x72,0x76,0x69,0x63,0x65,0x73,0x2F,0x41,0x6C,0x61,0x72,0x6D,0x45,0x76,0x65,0x6E,0x74,0x73,0x2E,0x6A,0x73,0x6F,0x6E,0x2F,0x73,0x61,0x76,0x65,0x41,0x6C,0x61,0x72,0x6D,0x45,0x76,0x65,0x6E,0x74,0x3F,0x62,0x75,0x69,0x6C,0x64,0x69,0x6E,0x67,0x49,0x64,0x3D,0x37,0x26,0x65,0x76,0x65,0x6E,0x74,0x54,0x79,0x70,0x65,0x3D,0x46,0x49,0x52,0x45,0x26,0x65,0x76,0x65,0x6E,0x74,0x44,0x65,0x74,0x61,0x69,0x6C,0x73,0x3D,0x46,0x49,0x52,0x45,0x2B,0x41,0x4C,0x41,0x52,0x4D,0x26,0x65,0x76,0x65,0x6E,0x74,0x47,0x65,0x6E,0x65,0x72,0x61,0x74,0x65,0x64,0x54,0x69,0x6D,0x65,0x49,0x6E,0x4D,0x69,0x6C,0x6C,0x69,0x73,0x3D,0x31,0x35,0x38,0x36,0x36,0x30,0x30,0x35,0x32,0x31,0x37,0x31,0x31,0x26,0x74,0x65,0x73,0x74,0x41,0x6C,0x61,0x72,0x6D,0x3D,0x4E,0x26,0x62,0x75,0x69,0x6C,0x64,0x69,0x6E,0x67,0x46,0x6C,0x6F,0x6F,0x72,0x4E,0x6F,0x3D,0x34,0x20,0x48,0x54,0x54,0x50,0x2F,0x31,0x2E,0x31,0x0D,0x0A,0x41,0x63,0x63,0x65,0x70,0x74,0x3A,0x20,0x61,0x70,0x70,0x6C,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x2F,0x6A,0x73,0x6F,0x6E,0x0D,0x0A,0x55,0x73,0x65,0x72,0x2D,0x41,0x67,0x65,0x6E,0x74,0x3A,0x20,0x4A,0x61,0x76,0x61,0x2F,0x31,0x2E,0x38,0x2E,0x30,0x5F,0x36,0x35,0x0D,0x0A,0x48,0x6F,0x73,0x74,0x3A,0x20,0x31,0x34,0x34,0x2E,0x32,0x31,0x37,0x2E,0x39,0x31,0x2E,0x33,0x32,0x3A,0x38,0x30,0x38,0x30,0x0D,0x0A,0x43,0x6F,0x6E,0x6E,0x65,0x63,0x74,0x69,0x6F,0x6E,0x3A,0x20,0x6B,0x65,0x65,0x70,0x2D,0x61,0x6C,0x69,0x76,0x65,0x0D,0x0A,0x0D,0x0A};
//Floor 5
uint8_t tstpkt1[]  = {0x50,0x4F,0x53,0x54,0x20,0x2F,0x46,0x50,0x57,0x65,0x62,0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x2F,0x66,0x70,0x73,0x65,0x72,0x76,0x69,0x63,0x65,0x73,0x2F,0x41,0x6C,0x61,0x72,0x6D,0x45,0x76,0x65,0x6E,0x74,0x73,0x2E,0x6A,0x73,0x6F,0x6E,0x2F,0x73,0x61,0x76,0x65,0x41,0x6C,0x61,0x72,0x6D,0x45,0x76,0x65,0x6E,0x74,0x3F,0x62,0x75,0x69,0x6C,0x64,0x69,0x6E,0x67,0x49,0x64,0x3D,0x37,0x26,0x65,0x76,0x65,0x6E,0x74,0x54,0x79,0x70,0x65,0x3D,0x46,0x49,0x52,0x45,0x26,0x65,0x76,0x65,0x6E,0x74,0x44,0x65,0x74,0x61,0x69,0x6C,0x73,0x3D,0x46,0x49,0x52,0x45,0x2B,0x41,0x4C,0x41,0x52,0x4D,0x26,0x65,0x76,0x65,0x6E,0x74,0x47,0x65,0x6E,0x65,0x72,0x61,0x74,0x65,0x64,0x54,0x69,0x6D,0x65,0x49,0x6E,0x4D,0x69,0x6C,0x6C,0x69,0x73,0x3D,0x31,0x35,0x38,0x36,0x36,0x30,0x30,0x35,0x32,0x31,0x37,0x31,0x31,0x26,0x74,0x65,0x73,0x74,0x41,0x6C,0x61,0x72,0x6D,0x3D,0x4E,0x26,0x62,0x75,0x69,0x6C,0x64,0x69,0x6E,0x67,0x46,0x6C,0x6F,0x6F,0x72,0x4E,0x6F,0x3D,0x35,0x20,0x48,0x54,0x54,0x50,0x2F,0x31,0x2E,0x31,0x0D,0x0A,0x41,0x63,0x63,0x65,0x70,0x74,0x3A,0x20,0x61,0x70,0x70,0x6C,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x2F,0x6A,0x73,0x6F,0x6E,0x0D,0x0A,0x55,0x73,0x65,0x72,0x2D,0x41,0x67,0x65,0x6E,0x74,0x3A,0x20,0x4A,0x61,0x76,0x61,0x2F,0x31,0x2E,0x38,0x2E,0x30,0x5F,0x36,0x35,0x0D,0x0A,0x48,0x6F,0x73,0x74,0x3A,0x20,0x31,0x34,0x34,0x2E,0x32,0x31,0x37,0x2E,0x39,0x31,0x2E,0x33,0x32,0x3A,0x38,0x30,0x38,0x30,0x0D,0x0A,0x43,0x6F,0x6E,0x6E,0x65,0x63,0x74,0x69,0x6F,0x6E,0x3A,0x20,0x6B,0x65,0x65,0x70,0x2D,0x61,0x6C,0x69,0x76,0x65,0x0D,0x0A,0x0D,0x0A};
//Floor 6
uint8_t tstpkt2[]  = {0x50,0x4F,0x53,0x54,0x20,0x2F,0x46,0x50,0x57,0x65,0x62,0x53,0x65,0x72,0x76,0x69,0x63,0x65,0x2F,0x66,0x70,0x73,0x65,0x72,0x76,0x69,0x63,0x65,0x73,0x2F,0x41,0x6C,0x61,0x72,0x6D,0x45,0x76,0x65,0x6E,0x74,0x73,0x2E,0x6A,0x73,0x6F,0x6E,0x2F,0x73,0x61,0x76,0x65,0x41,0x6C,0x61,0x72,0x6D,0x45,0x76,0x65,0x6E,0x74,0x3F,0x62,0x75,0x69,0x6C,0x64,0x69,0x6E,0x67,0x49,0x64,0x3D,0x37,0x26,0x65,0x76,0x65,0x6E,0x74,0x54,0x79,0x70,0x65,0x3D,0x46,0x49,0x52,0x45,0x26,0x65,0x76,0x65,0x6E,0x74,0x44,0x65,0x74,0x61,0x69,0x6C,0x73,0x3D,0x46,0x49,0x52,0x45,0x2B,0x41,0x4C,0x41,0x52,0x4D,0x26,0x65,0x76,0x65,0x6E,0x74,0x47,0x65,0x6E,0x65,0x72,0x61,0x74,0x65,0x64,0x54,0x69,0x6D,0x65,0x49,0x6E,0x4D,0x69,0x6C,0x6C,0x69,0x73,0x3D,0x31,0x35,0x38,0x36,0x36,0x30,0x30,0x35,0x32,0x31,0x37,0x31,0x31,0x26,0x74,0x65,0x73,0x74,0x41,0x6C,0x61,0x72,0x6D,0x3D,0x4E,0x26,0x62,0x75,0x69,0x6C,0x64,0x69,0x6E,0x67,0x46,0x6C,0x6F,0x6F,0x72,0x4E,0x6F,0x3D,0x36,0x20,0x48,0x54,0x54,0x50,0x2F,0x31,0x2E,0x31,0x0D,0x0A,0x41,0x63,0x63,0x65,0x70,0x74,0x3A,0x20,0x61,0x70,0x70,0x6C,0x69,0x63,0x61,0x74,0x69,0x6F,0x6E,0x2F,0x6A,0x73,0x6F,0x6E,0x0D,0x0A,0x55,0x73,0x65,0x72,0x2D,0x41,0x67,0x65,0x6E,0x74,0x3A,0x20,0x4A,0x61,0x76,0x61,0x2F,0x31,0x2E,0x38,0x2E,0x30,0x5F,0x36,0x35,0x0D,0x0A,0x48,0x6F,0x73,0x74,0x3A,0x20,0x31,0x34,0x34,0x2E,0x32,0x31,0x37,0x2E,0x39,0x31,0x2E,0x33,0x32,0x3A,0x38,0x30,0x38,0x30,0x0D,0x0A,0x43,0x6F,0x6E,0x6E,0x65,0x63,0x74,0x69,0x6F,0x6E,0x3A,0x20,0x6B,0x65,0x65,0x70,0x2D,0x61,0x6C,0x69,0x76,0x65,0x0D,0x0A,0x0D,0x0A};
uint16_t pkt_in_len;
uint16_t pktcount;
uint32_t periodic_timer;

uint8_t macaddr0[6] = {0x48,0x48,0x48,0x48,0x48,0x47};
uint32_t app_timeout=0;
uint8_t tcp_svr_ip[4] = {144,217,91,32};
volatile uint8_t tcp_app_state = 0; //0 - Not connected, 1- TCP Reg State, 2- TCP Alarm state
void uipclient_appcall(void){
	//USART3_Send(0x11);
	//printf("uip client call %d \n",tcp_app_state);
	//dhcpc_appcall();
	if(tcp_app_state == 1)
	{
		uip_send(tstreg,sizeof(tstreg));
		//uip_close();
		tcp_app_state = 0;
		printf("uip client send reg \n");
	}else if(tcp_app_state == 2){
		uip_send(tstpkt0,300);
		//uip_stop();
		tcp_app_state = 0;
		printf("uip client send alarm 2\n");
	}else if(tcp_app_state == 3){
		uip_send(tstpkt1,300);
		//uip_stop();
		tcp_app_state = 0;
		printf("uip client send alarm 3\n");
	}else if(tcp_app_state == 4){
		uip_send(tstpkt2,300);
		//uip_stop();
		tcp_app_state = 0;
		printf("uip client send alarm 4\n");
	}else
	{
		uip_close();
		tcp_app_state = 0;
		printf("Closing TCP\n");
	}

}

void uipudp_appcall(void){
	//USART3_Send(0x12);
	//printf("uip udp call \n");
	//if(uip_newdata()){
//	USART3_Send(0xAD);
//	for(int k=0x28;k<0x30;k++)
//		USART3_Send(uip_buf[k]);
//	USART3_Send(0xAD);
//	USART3_Send(0xAF);
	if(!dhcp_acquired)
		dhcpc_appcall();
	else
		uip_close();
	//}

}




void mac0_tick(void)
{
	//int k;
	pkt_in_len = enc424j600PacketReceiveP0(800,uip_buf);
	if(pkt_in_len > 0)
	{
		pktcount++;
		uip_len = pkt_in_len;
		//printf("uip pkt rcvd : %d  pkt count : %d :\n",pkt_in_len,pktcount);

		if(BUF->type == htons(UIP_ETHTYPE_IP))
		{
//			USART3_Send(0xAD);
//			for(k=0x28;k<0x30;k++)
//				USART3_Send(uip_buf[k]);
//			USART3_Send(0xAD);
//			USART3_Send(0xAE);
			//printf("IP Pkt\n");
//			if(uip_buf[0x22] == 0x1F && uip_buf[0x23] == 0x90){
//				printf("TCP Reply\n");
//				printf("\n -- \n");
//				for(k=0;k<uip_len;k++)
//				printf(" %d",uip_buf[k]);
//				printf("\n -- \n");
//			}
			uip_len = pkt_in_len;
			uip_arp_ipin();
			uip_input();
			if(uip_len > 0) {
				uip_arp_out();
//				if(uip_buf[0x24] == 0x1F && uip_buf[0x25] == 0x90){
//					printf("TCP Send\n");
//					printf("\n -- \n");
//					for(k=0;k<uip_len;k++)
//						printf(" %d",uip_buf[k]);
//					printf("\n -- \n");
//				}
				enc424j600PacketSendP0(uip_len, uip_buf);
				//printf("uip input reply pkt send \n");
			}
		}else if(BUF->type == htons(UIP_ETHTYPE_ARP))
		{
			//printf("ARP RECD \n");
			uip_arp_arpin();
			if(uip_len>0)
			{
//				USART3_Send(0xAD);
//				for(k=0;k<uip_len;k++)
//					USART3_Send(uip_buf[k]);
//				USART3_Send(0xAD);
				enc424j600PacketSendP0(uip_len, uip_buf);
				//printf("UIP ARP REPLY \n");
			}
		}
	//}else if(periodic_timer < (Sys_GetTick()-500)){
	}
	if(periodic_timer < (Sys_GetTick()-500)){
		periodic_timer = Sys_GetTick();
		//printf("periodic trigger\n");
		for(int i = 0; i < UIP_CONNS; ++i) {
			uip_len = 0;
			uip_periodic(i);
			if(uip_len > 0) {
//				USART3_Send(0xAE);
//				for(k=0;k<uip_len;k++)
//					USART3_Send(uip_buf[k]);
//				USART3_Send(0xAE);
				uip_arp_out();
				enc424j600PacketSendP0(uip_len, uip_buf);
				//printf("uip periodic pkt send %d\n",uip_len);
			}
		}
		if(!dhcp_acquired){
			for(int i = 0; i < UIP_UDP_CONNS; ++i) {
				uip_len = 0;
				uip_udp_periodic(i);
				//printf("UIP Periodic\n");
				if(uip_len > 0) {
	//				USART3_Send(0xAE);
	//				for(k=0;k<uip_len;k++)
	//					USART3_Send(uip_buf[k]);
	//				USART3_Send(0xAE);
	//				USART3_Send(0xAF);

					uip_arp_out();
					enc424j600PacketSendP0(uip_len, uip_buf);
					//printf("UIP UDP pkt send %d\n",uip_len);
				}
			}
		}
	}
}
uint8_t connect(uint8_t* ip, uint16_t port)
{

  uip_ipaddr_t ipaddr;
  uip_ip_addr(ipaddr, ip);
  struct uip_conn* conn = uip_connect(&ipaddr, htons(port));
  uint32_t timeout = Sys_GetTick() + 4000;
  printf("Inside Connect 1\n");
  mac0_tick();
  if (conn)
  {
	  //printf("Inside Connect 2\n");
	  while((conn->tcpstateflags & UIP_TS_MASK) != UIP_CLOSED)
      {
		  //printf("Inside Connect 3\n");
		  mac0_tick();
          //printf("tick exit");
          if ((conn->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED)
            {
//              data = (uip_userdata_t*) conn->appstate;

              printf("connected, state: waiting to close");
              //printf(", first packet in: ");
              //while((conn->tcpstateflags & UIP_TS_MASK) != UIP_CLOSED){
			//	mac0_tick();
				//printf(".%d\n",conn->tcpstateflags);
             // }
              printf("Closed TCP %d\n",conn->tcpstateflags);
              return 1;
            }

          if (((int32_t)(Sys_GetTick() - timeout)) > 0)
            {
              conn->tcpstateflags = UIP_CLOSED;
              break;
            }

        }
    }
  return 0;
}


void update_timestamp(uint8_t *tstpkt)
{
	int m,n;
	uint32_t current,i;
	uint8_t buf[20];
	//unsigned char temp;
	unsigned char s = 0;
	for(m=0;m<20;m++)
		buf[m] = '0';
	for(m=0;m<150;m++)
	{
		if(	(tstpkt[m+0] == 'M') &&
			(tstpkt[m+1] == 'i') &&
			(tstpkt[m+2] == 'l') &&
			(tstpkt[m+3] == 'l') &&
			(tstpkt[m+4] == 'i') &&
			(tstpkt[m+5] == 's') &&
			(tstpkt[m+6] == '='))
		{
			//current = Sys_GetTick() + 8001521711;
			current = RTC_GetCounter();

			//printf("Systick %d\n",current);
			i=current;
			while(i) {
				buf[s++] = i % 10 + '0';
				i /= 10;
			}
			buf[s] = '0';
			s-=1;
//			for(;t<s;t++,s--) {
//				temp = buf[s];
//				buf[s]=buf[t];
//				buf[t] = temp;
//			}
			//printf("Millis:");
			s= 0;
//			for(n=0;n<10;n++)
//				printf("%d",buf[n]);
//			printf("\n  millies");
			for(n=9;n>=0;n--){
				//printf("%d",buf[n]);
				tstpkt[m+7+s] = buf[n];
				s++;
			}
			tstpkt[m+16] = '0';
			tstpkt[m+17] = '0';
			tstpkt[m+18] = '0';
			//tstpkt[m+19] = '0';
			//printf("\n");
//			for(n=0;n<sizeof(tstpkt);n++)
//				USART3_Send(tstpkt[n]);
		}

	}
}


void mac0_init(void)
{
	Enc424J600Network_initP0(macaddr0);
	uip_seteth_addr(macaddr0);
	uip_init();
	uip_arp_init();

#ifdef DHCP
	printf("Initiating DHCP\n");
	dhcpc_init(macaddr0,6);

	//dhcpc_request();
	while(!dhcp_getip()){
		printf("Retrying DHCP...\n");
		Sys_Delay(1000);
		dhcpc_init(macaddr0,6);
//		dhcp_getip();
	}
	dhcp_acquired = 1;
	//dhcpc_appcall();
//	uip_ip_addr(ipaddr, myip_addr);
//	uip_sethostaddr(ipaddr);
//
//	uip_ip_addr(ipaddr, mygw_addr);
//	uip_setdraddr(ipaddr);
//
//	uip_ip_addr(ipaddr, mysn_addr);
//	uip_setnetmask(ipaddr);
	uint8_t dispip[4];
	uip_gethostaddr(dispip);
	printf("\n--------------------------\n");
	printf("IP : %d.%d.%d.%d\n",dispip[0],dispip[1],dispip[2],dispip[3]);
	uip_getdraddr(dispip);
	printf("GWIP : %d.%d.%d.%d\n",dispip[0],dispip[1],dispip[2],dispip[3]);
	uip_getnetmask(dispip);
	printf("NETMASK : %d.%d.%d.%d\n",dispip[0],dispip[1],dispip[2],dispip[3]);
	printf("--------------------------\n");
	//uip_gethostaddr(uip_netmask);
#endif
	printf("Init Complete Port 0\n");
	app_timeout = Sys_GetTick() + 10000;
	tcp_app_state = 0;

}


void mac0_service(uint8_t tcp_service_enable, uint8_t reg, uint8_t alarm_id)
{
	uint8_t conn_stat;
	if(tcp_service_enable)
	{
		//if((app_timeout < Sys_GetTick()) && (tcp_app_state == 0) && (reg == 1)){
		if((tcp_app_state == 0) && (reg == 1)){
			printf("Connecting tcp server for periodic reg pkt\n");
			tcp_app_state = 1;
			conn_stat = connect(tcp_svr_ip, 8080);
			if(!conn_stat){
				printf("Failed connection\n");
				connect(tcp_svr_ip, 8080);
			}
			app_timeout = Sys_GetTick() + 50000;
		}else if(alarm_id == 2){
			printf("Connecting tcp server for fire alarm pkt\n");
			update_timestamp(tstpkt0);
			tcp_app_state = 2;
			while(!connect(tcp_svr_ip, 8080));
			printf("Connected\n");

		}else if(alarm_id == 4){
			printf("Connecting tcp server for fire alarm pkt Floor 5\n");
			update_timestamp(tstpkt1);
			tcp_app_state = 3;
			while(!connect(tcp_svr_ip, 8080));
			printf("Connected\n");
		 }else if(alarm_id == 8){
			printf("Connecting tcp server for fire alarm pkt Floor 6\n");
			update_timestamp(tstpkt2);
			tcp_app_state = 4;
			while(!connect(tcp_svr_ip, 8080));
			printf("Connected\n");
		 }
	}
	uip_arp_timer();
}

//void mac0_service(uint8_t tcp_service_enable, uint8_t alarm_id)
//{
//	if(tcp_service_enable)
//	{
//		if((app_timeout < Sys_GetTick()) && (tcp_app_state == 0)){
//			printf("Connecting tcp server for periodic reg pkt\n");
//			tcp_app_state = 1;
//			while(!connect(tcp_svr_ip, 8080));
//
//			app_timeout = Sys_GetTick() + 50000;
//		}else if(!GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_4)){
//			printf("Connecting tcp server for fire alarm pkt\n");
//			update_timestamp(tstpkt0);
//			tcp_app_state = 2;
//			while(!connect(tcp_svr_ip, 8080));
//			printf("Connected\n");
//
//		}else if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_3)){
//			printf("Connecting tcp server for fire alarm pkt Floor 5\n");
//			update_timestamp(tstpkt1);
//			tcp_app_state = 3;
//			while(!connect(tcp_svr_ip, 8080));
//			printf("Connected\n");
//		 }else if(GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_2)){
//			printf("Connecting tcp server for fire alarm pkt Floor 6\n");
//			update_timestamp(tstpkt2);
//			tcp_app_state = 4;
//			while(!connect(tcp_svr_ip, 8080));
//			printf("Connected\n");
//		 }
//	}
//	uip_arp_timer();
//}
